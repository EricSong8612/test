{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-compiler.js"],"names":["normalize","require","_","printTransforms","ArgumentsOfCorrectTypeRule","DefaultValuesOfCorrectTypeRule","FragmentsOnCompositeTypesRule","KnownTypeNamesRule","LoneAnonymousOperationRule","PossibleFragmentSpreadsRule","ScalarLeafsRule","VariablesAreInputTypesRule","VariablesInAllowedPositionRule","validationRules","Runner","baseDir","schema","message","log","format","red","parseEverything","nodes","write","files","sync","filter","d","match","map","concat","getState","components","c","uniq","parser","parseFiles","compiledNodes","namePathMap","nameDefMap","documents","filePath","doc","errors","length","reportError","push","definitions","forEach","def","name","value","set","entries","compilerContext","addAll","convertASTDocuments","printContext","reduce","ctx","transform","node","kind","get","has","otherNode","text","getRoot","print","join","path","program","runner","directory","compileAll","queries","compile"],"mappings":"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","file":"query-compiler.js","sourcesContent":["// @flow\nimport path from \"path\"\nconst normalize = require(`normalize-path`)\nimport glob from \"glob\"\n\nimport { validate } from \"graphql\"\nimport invariant from \"invariant\"\nimport { IRTransforms } from \"relay-compiler\"\nimport ASTConvert from \"relay-compiler/lib/ASTConvert\"\nimport RelayCompilerContext from \"relay-compiler/lib/RelayCompilerContext\"\nimport filterContextForNode from \"relay-compiler/lib/filterContextForNode\"\nconst _ = require(`lodash`)\n\nimport { store } from \"../../redux\"\nimport FileParser from \"./file-parser\"\nimport QueryPrinter from \"./query-printer\"\nimport {\n  graphqlError,\n  graphqlValidationError,\n  multipleRootQueriesError,\n} from \"./graphql-errors\"\nimport report from \"../../reporter\"\n\nimport type { DocumentNode, GraphQLSchema } from \"graphql\"\n\nconst { printTransforms } = IRTransforms\n\nconst {\n  ArgumentsOfCorrectTypeRule,\n  DefaultValuesOfCorrectTypeRule,\n  FragmentsOnCompositeTypesRule,\n  KnownTypeNamesRule,\n  LoneAnonymousOperationRule,\n  PossibleFragmentSpreadsRule,\n  ScalarLeafsRule,\n  VariablesAreInputTypesRule,\n  VariablesInAllowedPositionRule,\n} = require(`graphql`)\n\ntype RootQuery = {\n  name: string,\n  path: string,\n  text: string,\n}\n\ntype Queries = Map<string, RootQuery>\n\nconst validationRules = [\n  ArgumentsOfCorrectTypeRule,\n  DefaultValuesOfCorrectTypeRule,\n  FragmentsOnCompositeTypesRule,\n  KnownTypeNamesRule,\n  LoneAnonymousOperationRule,\n  PossibleFragmentSpreadsRule,\n  ScalarLeafsRule,\n  VariablesAreInputTypesRule,\n  VariablesInAllowedPositionRule,\n]\n\nclass Runner {\n  baseDir: string\n  schema: GraphQLSchema\n\n  constructor(baseDir: string, schema: GraphQLSchema) {\n    this.baseDir = baseDir\n    this.schema = schema\n  }\n\n  reportError(message) {\n    report.log(`${report.format.red(`GraphQL Error`)} ${message}`)\n  }\n\n  async compileAll() {\n    let nodes = await this.parseEverything()\n    return await this.write(nodes)\n  }\n\n  async parseEverything() {\n    // FIXME: this should all use gatsby's configuration to determine parsable\n    // files (and how to parse them)\n    let files = glob.sync(`${this.baseDir}/**/*.+(t|j)s?(x)`)\n    files = files.filter(d => !d.match(/\\.d\\.ts$/))\n    files = files.map(normalize)\n\n    // Ensure all page components added as they're not necessarily in the\n    // pages directory e.g. a plugin could add a page component.  Plugins\n    // *should* copy their components (if they add a query) to .cache so that\n    // our babel plugin to remove the query on building is active (we don't\n    // run babel on code in node_modules). Otherwise the component will throw\n    // an error in the browser of \"graphql is not defined\".\n    files = files.concat(\n      Object.keys(store.getState().components).map(c => normalize(c))\n    )\n    files = _.uniq(files)\n\n    let parser = new FileParser()\n\n    return await parser.parseFiles(files)\n  }\n\n  async write(nodes: Map<string, DocumentNode>): Promise<Queries> {\n    const compiledNodes: Queries = new Map()\n    const namePathMap = new Map()\n    const nameDefMap = new Map()\n    const documents = []\n\n    for (let [filePath, doc] of nodes.entries()) {\n      let errors = validate(this.schema, doc, validationRules)\n\n      if (errors && errors.length) {\n        this.reportError(graphqlValidationError(errors, filePath))\n        return compiledNodes\n      }\n\n      documents.push(doc)\n      doc.definitions.forEach((def: any) => {\n        const name: string = def.name.value\n        namePathMap.set(name, filePath)\n        nameDefMap.set(name, def)\n      })\n    }\n\n    let compilerContext = new RelayCompilerContext(this.schema)\n    try {\n      compilerContext = compilerContext.addAll(\n        ASTConvert.convertASTDocuments(this.schema, documents, validationRules)\n      )\n    } catch (error) {\n      this.reportError(graphqlError(namePathMap, nameDefMap, error))\n      return compiledNodes\n    }\n\n    const printContext = printTransforms.reduce(\n      (ctx, transform) => transform(ctx, this.schema),\n      compilerContext\n    )\n\n    compilerContext.documents().forEach((node: { name: string }) => {\n      if (node.kind !== `Root`) return\n\n      const { name } = node\n      let filePath = namePathMap.get(name) || ``\n\n      if (compiledNodes.has(filePath)) {\n        let otherNode = compiledNodes.get(filePath)\n        this.reportError(\n          multipleRootQueriesError(\n            filePath,\n            nameDefMap.get(name),\n            otherNode && nameDefMap.get(otherNode.name)\n          )\n        )\n        return\n      }\n\n      let text = filterContextForNode(printContext.getRoot(name), printContext)\n        .documents()\n        .map(QueryPrinter.print)\n        .join(`\\n`)\n\n      compiledNodes.set(filePath, {\n        name,\n        text,\n        path: path.join(this.baseDir, filePath),\n      })\n    })\n\n    return compiledNodes\n  }\n}\n\nexport default async function compile(): Promise<Map<string, RootQuery>> {\n  const { program, schema } = store.getState()\n\n  const runner = new Runner(`${program.directory}/src`, schema)\n\n  const queries = await runner.compileAll()\n\n  return queries\n}\n"]}