"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _taggedTemplateLiteral2 = require("babel-runtime/helpers/taggedTemplateLiteral");

var _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _templateObject = (0, _taggedTemplateLiteral3.default)(["\n    ", "\n\n      ", "\n  "], ["\n    ", "\n\n      ", "\n  "]),
    _templateObject2 = (0, _taggedTemplateLiteral3.default)(["\n      query ", " {\n        bar {\n          #...\n        }\n      }\n\n      query ", " {\n        foo {\n          #...\n        }\n      }\n    "], ["\n      query ", " {\n        bar {\n          #...\n        }\n      }\n\n      query ", " {\n        foo {\n          #...\n        }\n      }\n    "]),
    _templateObject3 = (0, _taggedTemplateLiteral3.default)(["\n      query ", " {\n        bar {\n          #...\n        }\n        foo {\n          #...\n        }\n      }\n    "], ["\n      query ", " {\n        bar {\n          #...\n        }\n        foo {\n          #...\n        }\n      }\n    "]);

exports.multipleRootQueriesError = multipleRootQueriesError;
exports.graphqlValidationError = graphqlValidationError;
exports.graphqlError = graphqlError;

var _graphql = require("graphql");

var _babelCodeFrame = require("babel-code-frame");

var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _reporter = require("../../reporter");

var _reporter2 = _interopRequireDefault(_reporter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// These handle specific errors throw by RelayParser. If an error matches
// you get a pointer to the location in the query that is broken, otherwise
// we show the error and the query.
var handlers = [[/Unknown field `(.+)` on type `(.+)`/i, function (_ref, node) {
  var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
      name = _ref2[0];

  if (node.kind === "Field" && node.name.value === name) {
    return node.name.loc;
  }
  return null;
}], [/Unknown argument `(.+)`/i, function (_ref3, node) {
  var _ref4 = (0, _slicedToArray3.default)(_ref3, 1),
      name = _ref4[0];

  if (node.kind === "Argument" && node.name.value === name) {
    return node.name.loc;
  }
  return null;
}], [/Unknown directive `@(.+)`/i, function (_ref5, node) {
  var _ref6 = (0, _slicedToArray3.default)(_ref5, 1),
      name = _ref6[0];

  if (node.kind === "Directive" && node.name.value === name) {
    return node.name.loc;
  }
  return null;
}]];

function formatFilePath(filePath) {
  return _reporter2.default.format.bold("file:") + " " + _reporter2.default.format.blue(filePath);
}

function formatError(message, filePath, codeFrame) {
  return _reporter2.default.stripIndent(_templateObject, message, formatFilePath(filePath)) + ("\n\n" + codeFrame + "\n");
}

function extractError(error) {
  var docRegex = /Invariant Violation: RelayParser: (.*). Source: document `(.*)` file:/g;
  var matches = void 0;
  var message = "",
      docName = "";
  while ((matches = docRegex.exec(error.toString())) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (matches.index === docRegex.lastIndex) docRegex.lastIndex++;var _matches = matches;

    var _matches2 = (0, _slicedToArray3.default)(_matches, 3);

    message = _matches2[1];
    docName = _matches2[2];
  }
  return { message: message, docName: docName };
}

function findLocation(extractedMessage, def) {
  var location = null;
  (0, _graphql.visit)(def, {
    enter: function enter(node) {
      if (location) return;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(handlers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref7 = _step.value;

          var _ref8 = (0, _slicedToArray3.default)(_ref7, 2);

          var regex = _ref8[0];
          var handler = _ref8[1];

          var match = extractedMessage.match(regex);
          if (!match) continue;
          if (location = handler(match.slice(1), node)) break;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  });
  return location;
}

function getCodeFrame(query, lineNumber, column) {
  return (0, _babelCodeFrame2.default)(query, lineNumber, column, {
    linesAbove: 10,
    linesBelow: 10
  });
}

function getCodeFrameFromRelayError(def, extractedMessage, error) {
  var _ref9 = findLocation(extractedMessage, def) || {},
      start = _ref9.start,
      source = _ref9.source;

  var query = source ? source.body : (0, _graphql.print)(def);

  // we can't reliably get a location without the location source, since
  // the printed query may differ from the original.

  var _ref10 = source && (0, _graphql.getLocation)(source, start) || {},
      line = _ref10.line,
      column = _ref10.column;

  return getCodeFrame(query, line, column);
}

function multipleRootQueriesError(filePath, def, otherDef) {
  var name = def.name.value;
  var otherName = otherDef.name.value;
  var unifiedName = _lodash2.default.camelCase(name) + "And" + _lodash2.default.upperFirst(_lodash2.default.camelCase(otherName));

  return formatError("Multiple \"root\" queries found in file: \"" + name + "\" and \"" + otherName + "\". " + ("Only the first (\"" + otherName + "\") will be registered."), filePath, "  " + _reporter2.default.format.yellow("Instead of:") + " \n\n" + (0, _babelCodeFrame2.default)(_reporter2.default.stripIndent(_templateObject2, otherName, name)) + ("\n\n  " + _reporter2.default.format.green("Do:") + " \n\n") + (0, _babelCodeFrame2.default)(_reporter2.default.stripIndent(_templateObject3, unifiedName)));
}

function graphqlValidationError(errors, filePath, doc) {
  if (!errors || !errors.length) return "";
  var error = errors[0];
  var source = error.source,
      _error$locations = error.locations;
  _error$locations = _error$locations === undefined ? [{}] : _error$locations;

  var _error$locations2 = (0, _slicedToArray3.default)(_error$locations, 1),
      _error$locations2$ = _error$locations2[0],
      line = _error$locations2$.line,
      column = _error$locations2$.column;

  var query = source ? source.body : (0, _graphql.print)(doc);

  return formatError(error.message, filePath, getCodeFrame(query, line, column));
}

function graphqlError(namePathMap, nameDefMap, error) {
  var _extractError = extractError(error),
      message = _extractError.message,
      docName = _extractError.docName;

  var filePath = namePathMap.get(docName);

  if (filePath && docName) {
    return formatError(message, filePath, getCodeFrameFromRelayError(nameDefMap.get(docName), message, error));
  }

  message = "There was an error while compiling your site's GraphQL queries. ";
  if (error.message.match(/must be an instance of/)) {
    message += "This usually means that more than one instance of 'graphql' is installed " + "in your node_modules. Remove all but the top level one or run `npm dedupe` to fix it.";
  }

  return message;
}
//# sourceMappingURL=graphql-errors.js.map