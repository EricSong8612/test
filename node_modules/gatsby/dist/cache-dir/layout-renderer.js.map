{"version":3,"sources":["../../src/cache-dir/layout-renderer.js"],"names":["DefaultLayout","children","LayoutRenderer","props","state","location","pageResources","getResourcesForPathname","pathname","nextProps","setState","on","e","page","path","getPage","layout","key","Component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,gBAAgB,SAAhBA,aAAgB;AAAA,MAAGC,QAAH,QAAGA,QAAH;AAAA,SACpB;AAAA;AAAA;AACGA;AADH,GADoB;AAAA,CAAtB;;IAKMC,c;;;AACJ,0BAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AAEjB,UAAKC,KAAL,GAAa;AACXC,gBAAUF,MAAME,QADL;AAEXC,qBAAe,iBAAOC,uBAAP,CAA+BJ,MAAME,QAAN,CAAeG,QAA9C;AAFJ,KAAb;AAFiB;AAMlB;;;;8CAEyBC,S,EAAW;AACnC,UAAI,KAAKL,KAAL,CAAWC,QAAX,CAAoBG,QAApB,KAAiCC,UAAUJ,QAAV,CAAmBG,QAAxD,EAAkE;AAChE,aAAKE,QAAL,CAAc;AACZL,oBAAUI,UAAUJ;AADR,SAAd;AAGD;AACF;;;wCAEmB;AAAA;;AAClB;AACA;AACA;AACA,wBAAQM,EAAR,4BAAsC,aAAK;AACzC,YAAIC,EAAEC,IAAF,CAAOC,IAAP,KAAgB,iBAAOC,OAAP,CAAe,OAAKX,KAAL,CAAWC,QAAX,CAAoBG,QAAnC,EAA6CM,IAAjE,EAAuE;AACrE,iBAAKJ,QAAL,CAAc,EAAEJ,eAAeM,EAAEN,aAAnB,EAAd;AACD;AACF,OAJD;AAKD;;;6BAEQ;AACP,aAAO,0BAAc,KAAKF,KAAL,CAAWE,aAAX,CAAyBU,MAAzB,IAAmChB,aAAjD;AACLiB,aAAK,KAAKb,KAAL,CAAWE,aAAX,CAAyBU;AADzB,SAEF,KAAKb,KAFH,EAAP;AAID;;;EAjC0B,gBAAMe,S;;kBAoCpBhB,c","file":"layout-renderer.js","sourcesContent":["import React, { createElement } from \"react\"\nimport loader from \"./loader\"\nimport emitter from \"./emitter\"\n\nconst DefaultLayout = ({ children }) =>\n  <div>\n    {children()}\n  </div>\n\nclass LayoutRenderer extends React.Component {\n  constructor(props) {\n    super()\n    this.state = {\n      location: props.location,\n      pageResources: loader.getResourcesForPathname(props.location.pathname),\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (this.state.location.pathname !== nextProps.location.pathname) {\n      this.setState({\n        location: nextProps.location,\n      })\n    }\n  }\n\n  componentDidMount() {\n    // Listen to events so when our page gets updated, we can transition.\n    // This is only useful on delayed transitions as the page will get rendered\n    // without the necessary page resources and then re-render once those come in.\n    emitter.on(`onPostLoadPageResources`, e => {\n      if (e.page.path === loader.getPage(this.state.location.pathname).path) {\n        this.setState({ pageResources: e.pageResources })\n      }\n    })\n  }\n\n  render() {\n    return createElement(this.state.pageResources.layout || DefaultLayout, {\n      key: this.state.pageResources.layout,\n      ...this.props,\n    })\n  }\n}\n\nexport default LayoutRenderer\n"]}